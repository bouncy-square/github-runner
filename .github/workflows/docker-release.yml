name: Build and Publish Docker Image

on:
  release:
    types: [created, published]
  workflow_run:
    workflows: ["Auto Create Release"]
    types: [completed]
    branches: [main, staging, dev]
  workflow_dispatch:
    inputs:
      release_tag:
        description: 'Release tag to build'
        required: true
        type: string

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}
  DOCKER_BUILDKIT: 1

permissions:
  contents: write 
  packages: write
  actions: read

jobs:
  debug:
    name: Debug Event
    runs-on: ubuntu-latest
    steps:
      - name: Debug GitHub Event
        run: |
          echo "Event name: ${{ github.event_name }}"
          if [[ "${{ github.event_name }}" == "release" ]]; then
            echo "Event action: ${{ github.event.action }}"
            echo "Release state: ${{ github.event.release.draft }}"
            echo "Release prerelease: ${{ github.event.release.prerelease }}"
            echo "Release published_at: ${{ github.event.release.published_at }}"
            echo "Release tag: ${{ github.event.release.tag_name }}"
          elif [[ "${{ github.event_name }}" == "workflow_run" ]]; then
            echo "Workflow run conclusion: ${{ github.event.workflow_run.conclusion }}"
            echo "Workflow run name: ${{ github.event.workflow_run.name }}"
            echo "Workflow run head branch: ${{ github.event.workflow_run.head_branch }}"
          elif [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "Manual trigger with tag: ${{ github.event.inputs.release_tag }}"
          fi

  build-and-publish:
    name: Build and Publish
    runs-on: ubuntu-latest
    # Run for: successful auto-release workflow, manual releases, or manual dispatch
    if: |
      (github.event_name == 'workflow_run' && github.event.workflow_run.conclusion == 'success') ||
      github.event_name == 'release' ||
      github.event_name == 'workflow_dispatch'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Get release information
        id: get_release
        uses: actions/github-script@v6
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            let releaseTag = '';
            let branchName = 'main';
            let releaseId = '';
            let releaseBody = '';
            
            if ('${{ github.event_name }}' === 'workflow_dispatch') {
              releaseTag = '${{ github.event.inputs.release_tag }}';
              console.log('Using workflow_dispatch release tag:', releaseTag);
            } else if ('${{ github.event_name }}' === 'release') {
              // Direct release event
              releaseTag = '${{ github.event.release.tag_name }}';
              branchName = '${{ github.event.release.target_commitish }}' || 'main';
              releaseId = '${{ github.event.release.id }}';
              releaseBody = `${{ github.event.release.body }}` || '';
              console.log('Using direct release event:', releaseTag);
            } else {
              // workflow_run - get latest release
              try {
                const { data: release } = await github.rest.repos.getLatestRelease({
                  owner: context.repo.owner,
                  repo: context.repo.repo
                });
                
                releaseTag = release.tag_name;
                branchName = release.target_commitish || 'main';
                releaseId = release.id;
                releaseBody = release.body || '';
                
                console.log('Found latest release from workflow_run:', releaseTag);
                console.log('Target branch:', branchName);
              } catch (error) {
                console.log('Error getting release:', error.message);
                core.setFailed('Could not find latest release');
                return;
              }
            }
            
            core.setOutput('release_tag', releaseTag);
            core.setOutput('branch_name', branchName);
            core.setOutput('release_id', releaseId);
            core.setOutput('release_body', releaseBody);

      - name: Extract branch name and version
        shell: bash
        run: |
          RELEASE_TAG="${{ steps.get_release.outputs.release_tag }}"
          BRANCH_NAME="${{ steps.get_release.outputs.branch_name }}"
          
          # Sanitize branch name for Docker tag (replace / and other invalid chars with -)
          SANITIZED_BRANCH=$(echo "$BRANCH_NAME" | sed 's/[^a-zA-Z0-9._-]/-/g' | sed 's/--*/-/g' | sed 's/^-\|-$//g')
          echo "BRANCH_NAME=$BRANCH_NAME" >> $GITHUB_ENV
          echo "SANITIZED_BRANCH=$SANITIZED_BRANCH" >> $GITHUB_ENV
          echo "VERSION=$RELEASE_TAG" >> $GITHUB_ENV
          echo "Branch: $BRANCH_NAME"
          echo "Sanitized: $SANITIZED_BRANCH"
          echo "Version: $RELEASE_TAG"

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          driver-opts: image=moby/buildkit:master
          install: true
          
      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata (tags, labels) for Docker
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            # For releases: create version tags
            type=semver,pattern={{version}},value=${{ env.VERSION }}
            type=semver,pattern={{major}}.{{minor}},value=${{ env.VERSION }}
            type=semver,pattern={{major}},value=${{ env.VERSION }}
            type=semver,pattern=${{ env.SANITIZED_BRANCH }}-{{version}},value=${{ env.VERSION }}
            
            # For branches: create branch-based tags
            type=raw,value=${{ env.SANITIZED_BRANCH }}-latest
            
            # SHA tag
            type=sha,format=long,prefix=${{ env.SANITIZED_BRANCH }}-sha-

      - name: Cache Docker layers
        uses: actions/cache@v3
        with:
          path: /tmp/.buildx-cache
          key: ${{ runner.os }}-buildx-${{ env.SANITIZED_BRANCH }}-${{ github.sha }}
          restore-keys: |
            ${{ runner.os }}-buildx-${{ env.SANITIZED_BRANCH }}-
            ${{ runner.os }}-buildx-

      - name: Debug environment variables
        run: |
          echo "=== GitHub Context Debug ==="
          echo "Event name: ${{ github.event_name }}"
          echo "GitHub ref: ${{ github.ref }}"
          echo "GitHub ref name: ${{ github.ref_name }}"
          echo "GitHub SHA: ${{ github.sha }}"
          
          echo "=== Final Environment Variables ==="
          echo "BRANCH_NAME: ${{ env.BRANCH_NAME }}"
          echo "SANITIZED_BRANCH: ${{ env.SANITIZED_BRANCH }}"
          echo "VERSION: ${{ env.VERSION }}"

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=local,src=/tmp/.buildx-cache
          cache-to: type=local,dest=/tmp/.buildx-cache-new
          build-args: |
            BRANCH_NAME=${{ env.BRANCH_NAME }}
            SANITIZED_BRANCH=${{ env.SANITIZED_BRANCH }}
            environ=${{ env.SANITIZED_BRANCH }}
            version=${{ env.VERSION }}

      - name: Update Release with Image Info
        if: success() && steps.get_release.outputs.release_id != ''
        uses: actions/github-script@v6
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const { owner, repo } = context.repo;
            const releaseId = '${{ steps.get_release.outputs.release_id }}';
            const version = '${{ env.VERSION }}';
            const branchName = '${{ env.BRANCH_NAME }}';
            const sanitizedBranch = '${{ env.SANITIZED_BRANCH }}';
            const registry = '${{ env.REGISTRY }}'.toLowerCase();
            const ownerLower = owner.toLowerCase();
            const imageName = `${registry}/${ownerLower}/${repo}`;
            const releaseBody = `${{ steps.get_release.outputs.release_body }}`;
            
            const versionMatch = version.match(/v?(\d+)\.(\d+)\.(\d+)/);
            const majorVersion = versionMatch ? versionMatch[1] : '';
            const minorVersion = versionMatch ? `${versionMatch[1]}.${versionMatch[2]}` : '';
            
            const message = `\n\n### üê≥ Docker Image\n` +
                          `**Latest Image:** \`${imageName}:${sanitizedBranch}-latest\`\n` +
                          `**Version Tag:** \`${imageName}:${version}\`\n` +
                          `**Branch Version:** \`${imageName}:${sanitizedBranch}-${version}\`\n` +
                          (majorVersion ? `**Major Version:** \`${imageName}:${majorVersion}\`\n` : '') +
                          (minorVersion ? `**Minor Version:** \`${imageName}:${minorVersion}\`\n` : '') +
                          `**SHA Tag:** \`${imageName}:${sanitizedBranch}-sha-${{ github.sha }}\`\n\n` +
                          `#### Pull Commands\n\`\`\`bash\n` +
                          `# Pull by version (recommended)\ndocker pull ${imageName}:${version}\n\n` +
                          `# Pull by branch version\ndocker pull ${imageName}:${sanitizedBranch}-${version}\n\n` +
                          `# Pull latest from branch\ndocker pull ${imageName}:${sanitizedBranch}-latest\n\`\`\``;

            try {
              await github.rest.repos.updateRelease({
                owner,
                repo,
                release_id: releaseId,
                body: releaseBody + message
              });
              console.log('Successfully updated release with Docker info');
            } catch (error) {
              console.log('Failed to update release:', error.message);
            }

      - name: Move cache
        run: |
          rm -rf /tmp/.buildx-cache
          mv /tmp/.buildx-cache-new /tmp/.buildx-cache